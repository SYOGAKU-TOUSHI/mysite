<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>JS_Cheat_Sheet_011</title>
    <!-- link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css" -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/base16/solarized-light.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

<style>
@font-face {
	font-family: 'M+ 1mn';
	src: url('file:///C:/Windows/Fonts/mplus-1mn-regular.ttf') format('truetype');
	font-weight: normal;
	font-style: normal;
}

html, body {
	width: 100%;
	height: 100%;
	padding: 0.5em;
	margin: 0;
	box-sizing: border-box;
}
body {
	line-height: 175%;
	font-family: Meiryo;
}
pre {
	line-height: 150%;
	font-size: 1rem;
}
code {
	border-radius: 0.5em;
	border-top:    solid 2px #edddb2;
	border-left:   solid 2px #edddb2;
	border-right:  solid 2px #edddb2;
	border-bottom: solid 2px #edddb2;
	box-sizing: border-box;
	font-family: 'M+ 1mn';
}
blockquote {
	border-left: solid 0.3em #8ac;
	margin-left: 0;
	padding-left: 1.7em;
}

h1 {
	text-align: center;
	padding: 0.5em;
	background-color: #8ac;
	color: #fff;
	border-radius: 0.2em;
	height: 16em;
	margin-bottom: 2em;

	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}
h2 {
	border: solid 2px #8ac;
	border-left:  solid 1em #8ac;
	border-right: solid 1em #8ac;
	padding: 0.5em;
	border-radius: 0.5em;
}
h3 {
	border-bottom: solid 2px #8ac;
	padding: 0em;
	margin-top: 2em;
}
h2 + h3 {
	margin-top: 1em;
}

hr {
	border-width: 0;
	height: 0;
	margin: 0;
	padding: 0;
	break-after: page;
}

.hljs-comment {
	color: #15915a;
}
</style>

  </head>
  <body>
<h1 id="section-1">[付録] JavaScriptチートシート</h1>
<blockquote>
<p>著：柳井政和<br>Ver：1.2.0 (2021-11-29)</p>
</blockquote>
<p>　講義の付録の、JavaScript速習用チートシートです。他言語プログラマー、あるいはJavaScriptの仕様にそれほど詳しくない人向けの、ポイントを絞った説明です。<br>　JavaScriptの仕様を細かく知りたい際は、MDNを見るとよいです。「MDN 検索したい内容」でGoogle検索すると、目的のページが見つかり便利です。</p>
<p>JavaScript | MDN<br><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript">https://developer.mozilla.org/ja/docs/Web/JavaScript</a></p>
<hr>
<h2 id="section-2">■ 事前知識</h2>
<h3 id="section-3">● コメント</h3>
<p>　コメントは「//」の右側。<br>　あるいは「/* ～ */」の間（こちらは複数行可能）。</p>
<pre><code class="language-js"><span class="hljs-string">&#x27;プログラム&#x27;</span>    <span class="hljs-comment">// コメント</span>
<span class="hljs-comment">/*
    コメント1
    コメント2
*/</span>
</code></pre>
<h3 id="section-4">● セミコロン</h3>
<p>　文の区切りの「;」は、付けても付けなくても構わない。どちらかに統一して記述した方がよい。</p>
<h3 id="section-5">● コンソールへの出力</h3>
<p>　Webブラウザの「コンソール」は、以下の手順です。</p>
<ol>
<li>Webページを右クリックして「検証」を選ぶ。開発者ツール（DevTools）が表示される。</li>
<li>開発者ツールの「Console」タブを選ぶ。</li>
</ol>
<p>　「console.log( ～ )」でコンソールに情報を出力できる。「～」の部分には、「,」（カンマ）区切りで、複数の値や変数、式を書くことができる。</p>
<p>Chrome DevTools - Chrome Developers<br><a href="https://developer.chrome.com/docs/devtools/">https://developer.chrome.com/docs/devtools/</a></p>
<hr>
<h2 id="section-6">■ 変数と定数</h2>
<h3 id="section-7">● let、const とブロック スコープ</h3>
<p>　変数の宣言は「let」、定数の宣言は「const」。それぞれのスコープ（有効範囲）は「{ ～ }」（波括弧）の範囲内（ブロック スコープ）。定数は変数の一種で、再代入不可能なものを指す。</p>
<pre><code class="language-js">{ <span class="hljs-regexp">//</span> ←これがブロック スコープの開始
    <span class="hljs-regexp">//</span> ↑この範囲で変数や定数が有効
    let n1 = <span class="hljs-number">123</span>;    <span class="hljs-regexp">//</span> 変数（値を差し替え可能）
    const n2 = <span class="hljs-number">456</span>;  <span class="hljs-regexp">//</span> 定数（値を差し替え不能）

    console.log(n1, n2);  <span class="hljs-regexp">//</span> <span class="hljs-number">123</span>, <span class="hljs-number">456</span>

    n1 = <span class="hljs-number">789</span>;  <span class="hljs-regexp">//</span> 変数は値を差し替え可能（再代入可能）

    console.log(n1, n2);  <span class="hljs-regexp">//</span> <span class="hljs-number">789</span>, <span class="hljs-number">123</span>

    <span class="hljs-regexp">//</span> ↓この範囲で変数や定数が有効
} <span class="hljs-regexp">//</span> ←これがブロック スコープの終了
</code></pre>
<p>　変数には、数値でも文字列でもオブジェクトでも、何を入れてもよい。数値を入れていた変数に文字列を入れるなど、入れる内容を変更してもよい。</p>
<h3 id="section-8">● var と関数スコープ</h3>
<p>　変数の宣言には「var」もある。こちらは古い宣言方法で、スコープ（有効範囲）が広い。スコープ（有効範囲）は「function() { ～ }」の範囲内（関数スコープ）。また、同じスコープ内で再宣言可能。let と const はできない。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> hoge() { <span class="hljs-regexp">//</span> ←これが関数スコープの開始
    {
        var n3 = <span class="hljs-number">789</span>;  <span class="hljs-regexp">//</span> 値を差し替え可能な変数
        console.log(n3);  <span class="hljs-regexp">//</span> <span class="hljs-number">789</span>
    }

    <span class="hljs-regexp">//</span> 関数スコープ単位なので
    <span class="hljs-regexp">//</span> ブロック スコープの外でも使える
    console.log(n3);  <span class="hljs-regexp">//</span> <span class="hljs-number">789</span>

    <span class="hljs-regexp">//</span> 同じ階層で、同じ変数名を利用できる
    var n3 = <span class="hljs-number">123</span>;  <span class="hljs-regexp">//</span> 再宣言可能
    console.log(n3);  <span class="hljs-regexp">//</span> <span class="hljs-number">123</span>

} <span class="hljs-regexp">//</span> ←これが関数スコープの終了
</code></pre>
<hr>
<h2 id="section-9">■ 数値</h2>
<h3 id="section-10">● 整数と小数点数</h3>
<p>　数値は数字をそのまま書く。小数点を付ければ小数点数になる。小数点数は、丸め誤差が発生することがあるので注意が必要。</p>
<pre><code class="language-js"><span class="hljs-attribute">let</span> n1 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;      // n1は <span class="hljs-number">3</span>
<span class="hljs-attribute">let</span> n2 = <span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span>;  // n2は <span class="hljs-number">0</span>.<span class="hljs-number">30000000000000004</span>
</code></pre>
<h3 id="section-11">● 整数化</h3>
<p>　Math.trunc()を使うと小数点以下を切り捨てて整数にできる。</p>
<pre><code class="language-js"><span class="hljs-attribute">let</span> n1 = Math.trunc(<span class="hljs-number">12</span>.<span class="hljs-number">34</span>);  // <span class="hljs-number">12</span>
</code></pre>
<p>簡便な方法として「n | 0」（有効な整数部分のビットの、OR演算を0とおこなう）の計算でも代用できる。</p>
<pre><code class="language-js"><span class="hljs-attribute">let</span> n2 = <span class="hljs-number">12</span>.<span class="hljs-number">34</span> | <span class="hljs-number">0</span>;  // <span class="hljs-number">12</span>
</code></pre>
<h3 id="section-12">● その他</h3>
<p>　「MDN Number」でGoogle検索すれば、数値の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number</a></p>
<p>　「MDN Math」でGoogle検索すれば、各種の数学関数が分かる。最大値、最小値、三角関数など、さまざまな関数が用意されている。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math</a></p>
<hr>
<h2 id="section-13">■ 文字列</h2>
<h3 id="section-14">● 文字列の初期化</h3>
<p>　文字列は、シングルクォートやダブルクォート、バッククォートで囲む。エスケープする際は、バックスラッシュを使う。<br>　バッククォートで囲んだ際、「${n}」のように「${ ～ }」で囲んだ領域は、変数や式など、コードを直接書くことができる。</p>
<pre><code class="language-js">let s1 = <span class="hljs-string">&#x27;abc&#x27;</span>;      <span class="hljs-regexp">//</span> abc
let s2 = <span class="hljs-string">&quot;\&quot;def\&quot;&quot;</span>;  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;def&quot;</span>
let s3 = `ABC <span class="hljs-variable">${s1}</span> <span class="hljs-variable">${s2}</span> DEF`;  <span class="hljs-regexp">//</span> ABC abc <span class="hljs-string">&quot;def&quot;</span> DEF
</code></pre>
<p>　改行は「\n」。タブ文字は「\t」。</p>
<h3 id="section-15">● 文字列の長さ</h3>
<p>　文字列の長さは「.length」で得られる。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;
<span class="hljs-keyword">let</span> n = s.<span class="hljs-property">length</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s, n);  <span class="hljs-comment">// abcdefg 7</span>
</code></pre>
<h3 id="section-16">● 文字列の関数</h3>
<p>　文字列の一部を得たりする各種の関数が、文字列にはある。<br>　以下は、文字列の一部を得る関数。先頭の2文字目から、5文字目の1つ前までの文字を得ている。文字列の位置は0から数える。</p>
<pre><code class="language-js">let <span class="hljs-built_in">s1</span> = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;
let <span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.<span class="hljs-keyword">substring(2, </span><span class="hljs-number">5</span>);

console.log(<span class="hljs-built_in">s1</span>, <span class="hljs-built_in">s2</span>)<span class="hljs-comment">;  // abcdefg cde</span>
</code></pre>
<h3 id="section-17">● その他</h3>
<p>　「MDN String」でGoogle検索すれば、文字列の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String</a></p>
<hr>
<h2 id="section-18">■ 配列と for 文</h2>
<h3 id="section-19">● 配列の基本</h3>
<p>　配列は、Arrayオブジェクトである。多くの場合「[]」（角括弧）を利用して作る。各要素は「[数値]」という添え字を利用してアクセスする。値が入っていない要素は「undefined」（未定義）となる。配列の長さは「.length」で得る。</p>
<pre><code class="language-js"><span class="hljs-regexp">//</span> 配列の初期化
let a1 = new Array(<span class="hljs-number">2</span>);   <span class="hljs-regexp">//</span> [empty × <span class="hljs-number">2</span>]
let a2 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];     <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]

<span class="hljs-regexp">//</span> 配列の要素数
console.log(a2.length);  <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>

<span class="hljs-regexp">//</span> ネストした配列
let a3 = [<span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]];  <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]
</code></pre>
<pre><code class="language-js"><span class="hljs-regexp">//</span> 添え字を用いて値の変更や読み取り
let a4 = [];
a4[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;abc&#x27;</span>;  <span class="hljs-regexp">//</span> 先頭の添え字は「<span class="hljs-number">0</span>」
a4[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;def&#x27;</span>;
a4[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;ghi&#x27;</span>;

<span class="hljs-regexp">//</span> 各要素を出力
<span class="hljs-regexp">//</span> 中身がない要素は「undefined」（未定義）になる
console.log(a4);      <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, empty × <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>]
console.log(a4[-<span class="hljs-number">1</span>]);  <span class="hljs-regexp">//</span> undefined
console.log(a4[<span class="hljs-number">0</span>]);   <span class="hljs-regexp">//</span> abc
console.log(a4[<span class="hljs-number">1</span>]);   <span class="hljs-regexp">//</span> def
console.log(a4[<span class="hljs-number">2</span>]);   <span class="hljs-regexp">//</span> undefined
console.log(a4[<span class="hljs-number">3</span>]);   <span class="hljs-regexp">//</span> undefined
console.log(a4[<span class="hljs-number">4</span>]);   <span class="hljs-regexp">//</span> ghi
</code></pre>
<h3 id="section-20">● for 文</h3>
<p>　以下のように書く。</p>
<pre><code class="language-js"><span class="hljs-regexp">//</span> 配列の要素数だけ処理をおこない、各要素を出力
let arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.length; i ++) {
    console.log(i, arr[i]);
}

<span class="hljs-regexp">//</span> <span class="hljs-number">0</span> <span class="hljs-string">&#x27;a&#x27;</span>
<span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <span class="hljs-string">&#x27;b&#x27;</span>
<span class="hljs-regexp">//</span> <span class="hljs-number">2</span> <span class="hljs-string">&#x27;c&#x27;</span>
</code></pre>
<p>　途中で処理を飛ばして制御部分に戻るには「continue」を使う。<br>　途中で処理を中断して for 文から抜けるには「break」を使う。</p>
<h3 id="section-21">● 配列の関数</h3>
<p>　配列には、他のプログラミング言語にも見られる各種メソッドがある。</p>
<pre><code class="language-js">let a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];
a.push(<span class="hljs-string">&#x27;f&#x27;</span>);     <span class="hljs-regexp">//</span> 末尾に追加
console.log(a);  <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]
</code></pre>
<p>　また、反復メソッド（map, filter, forEach, reduce など）もある。</p>
<pre><code class="language-js">let arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
arr.forEach((x, i) =&gt; {
    console.log(i, arr[i]);
});

<span class="hljs-regexp">//</span> <span class="hljs-number">0</span> <span class="hljs-string">&#x27;a&#x27;</span>
<span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <span class="hljs-string">&#x27;b&#x27;</span>
<span class="hljs-regexp">//</span> <span class="hljs-number">2</span> <span class="hljs-string">&#x27;c&#x27;</span>
</code></pre>
<h3 id="section-22">● その他</h3>
<p>　「MDN Array」でGoogle検索すれば、配列の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>
<hr>
<h2 id="section-23">■ オブジェクト</h2>
<h3 id="section-24">● オブジェクトの基本</h3>
<p>　オブジェクトは、Objectオブジェクトである。多くの場合「{}」（波括弧）を利用して作る。各要素（プロパティ）は「オブジェクト[プロパティ名]」あるいは「オブジェクト.プロパティ名」の形でアクセスする。値が入っていないプロパティは、「undefined」（未定義）となる。</p>
<pre><code class="language-js"><span class="hljs-comment">// オブジェクトの作成</span>
let user = {<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;hawk&#x27;</span>, hp: <span class="hljs-number">100</span>, mp: <span class="hljs-number">50</span>, level: <span class="hljs-number">1</span>, <span class="hljs-built_in">exp</span>: <span class="hljs-number">10</span>};

<span class="hljs-comment">// プロパティの読み取り</span>
console.<span class="hljs-built_in">log</span>(user.<span class="hljs-built_in">name</span>);   <span class="hljs-comment">// hawk</span>
console.<span class="hljs-built_in">log</span>(user[<span class="hljs-string">&#x27;hp&#x27;</span>]);  <span class="hljs-comment">// 100</span>

<span class="hljs-comment">// 空のプロパティは「undefined」（未定義）になる</span>
console.<span class="hljs-built_in">log</span>(user.<span class="hljs-built_in">skill</span>);  <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// プロパティの変更</span>
user.<span class="hljs-built_in">skill</span> = <span class="hljs-string">&#x27;fire&#x27;</span>;
console.<span class="hljs-built_in">log</span>(user.<span class="hljs-built_in">skill</span>);  <span class="hljs-comment">// fire</span>
</code></pre>
<h3 id="section-25">● その他</h3>
<p>　「MDN Object」でGoogle検索すれば、オブジェクトの仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object</a></p>
<hr>
<h2 id="section-26">■ 分割代入</h2>
<h3 id="section-27">● 配列の分割代入</h3>
<p>　変数への代入時に「[ ]」（角括弧）を使うことで、要素を分割して代入できる。代入の際は、要素の先頭から順に格納する。</p>
<pre><code class="language-js"><span class="hljs-regexp">//</span> 配列の作成
const arr = [<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;monkey&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>];

<span class="hljs-regexp">//</span> 配列の要素を先頭から分割代入
const [a, b, c] = arr;

console.log(a);  <span class="hljs-regexp">//</span> dog
console.log(b);  <span class="hljs-regexp">//</span> cat
console.log(c);  <span class="hljs-regexp">//</span> monkey
</code></pre>
<h3 id="section-28">● オブジェクトの分割代入</h3>
<p>　変数への代入時に「{ }」（波括弧）を使うことで、プロパティを分割して代入できる。代入の際は、変数名と同じプロパティの値を格納する。</p>
<pre><code class="language-js"><span class="hljs-comment">// オブジェクトの作成</span>
const chara = {<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, hp: <span class="hljs-number">100</span>, mp: <span class="hljs-number">8</span>, <span class="hljs-built_in">skill</span>: <span class="hljs-string">&#x27;sword&#x27;</span>};

<span class="hljs-comment">// オブジェクトのプロパティから、プロパティ名の値を分割代入</span>
const {<span class="hljs-built_in">name</span>, hp, mp} = chara;

console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">name</span>);  <span class="hljs-comment">// Bob</span>
console.<span class="hljs-built_in">log</span>(hp);    <span class="hljs-comment">// 100</span>
console.<span class="hljs-built_in">log</span>(mp);    <span class="hljs-comment">// 8</span>
</code></pre>
<h3 id="section-29">● その他</h3>
<p>　「MDN 分割代入」でGoogle検索すれば、分割代入の仕様が分かる。分割代入は、さらに複雑な代入がおこなえる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></p>
<hr>
<h2 id="section-30">■ 関数</h2>
<h3 id="section-31">● function</h3>
<p>　JavaScriptの関数の書き方は多くの種類がある。基本は「function」という予約語を使う。「function 関数名 (引数) {処理}」と書く以外に、「function (引数) {処理}」と無名関数を書く方法がある。「return 値」で戻り値（返り値）を戻せる。JavaScriptの関数はオブジェクトである。</p>
<pre><code class="language-js"><span class="hljs-comment">// 関数の作成</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span> (<span class="hljs-params">arg1, arg2</span>) </span>{
    <span class="hljs-comment">// 処理</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`result: <span class="hljs-subst">${arg1}</span>, <span class="hljs-subst">${arg2}</span>`</span>;
}

<span class="hljs-comment">// 関数の呼び出し</span>
<span class="hljs-built_in">console</span>.log(func1(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>));  <span class="hljs-comment">// result: 111, 222</span>

<span class="hljs-keyword">let</span> func2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, arg2</span>) </span>{
    <span class="hljs-comment">// 処理</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`result: <span class="hljs-subst">${arg1}</span>, <span class="hljs-subst">${arg2}</span>`</span>;
};

<span class="hljs-comment">// 関数の呼び出し</span>
<span class="hljs-built_in">console</span>.log(func2(<span class="hljs-number">333</span>, <span class="hljs-number">444</span>));  <span class="hljs-comment">// result: 333, 444</span>
</code></pre>
<h3 id="section-32">● アロー関数</h3>
<p>　関数には、より簡便なアロー関数もある。「(引数) =&gt; {処理}」と書くことで、関数を短く書ける。</p>
<pre><code class="language-js"><span class="hljs-comment">// アロー関数 基本</span>
let arrow1 = <span class="hljs-function">(<span class="hljs-params">arg1, arg2</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`result: <span class="hljs-subst">${arg1}</span>, <span class="hljs-subst">${arg2}</span>`</span>;
};

<span class="hljs-comment">// アロー関数 簡略</span>
<span class="hljs-comment">// 処理がreturn文1行なら、波括弧とreturnを省ける</span>
let arrow2 = <span class="hljs-function">(<span class="hljs-params">arg1, arg2</span>) =&gt;</span> <span class="hljs-string">`result: <span class="hljs-subst">${arg1}</span>, <span class="hljs-subst">${arg2}</span>`</span>;

<span class="hljs-comment">// アロー関数 簡略</span>
<span class="hljs-comment">// 引数が1つなら丸括弧を省ける</span>
let arrow3 = <span class="hljs-function"><span class="hljs-params">arg1</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`result: <span class="hljs-subst">${arg1}</span>`</span>;
};

<span class="hljs-comment">// アロー関数 簡略</span>
<span class="hljs-comment">// 引数が0なら丸括弧のみを書く</span>
let arrow4 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`result`</span>;
};

<span class="hljs-comment">// アロー関数 簡略</span>
<span class="hljs-comment">// このように短く書く処理もある</span>
let arrow5 = <span class="hljs-function"><span class="hljs-params">arg1</span> =&gt;</span> <span class="hljs-string">`result: <span class="hljs-subst">${arg1}</span>`</span>;
</code></pre>
<p>　アロー関数は、配列の反復メソッド（map, forEach, filter, reduce など）と一緒によく使う。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">489</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x, i</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${i}</span>: <span class="hljs-subst">${x * <span class="hljs-number">10</span>}</span>`</span>));  <span class="hljs-comment">// [&#x27;0: 1230&#x27;, &#x27;1: 4560&#x27;, &#x27;2: 4890&#x27;]</span>
</code></pre>
<p>　配列の「map」は加工した新しい配列を作る。「forEach」は全ての要素に対して処理をおこなう。「filter」は条件を指定して要素を絞り込む。「reduce」は、要素をまとめて合計値を出したりする際に使う。</p>
<h3 id="section-33">● 関数のthis</h3>
<p>　関数の this は、その関数の親に当たるオブジェクトを指す（ことが多い）。オブジェクトのプロパティになっている関数のことを、特別にメソッドと呼ぶ。</p>
<pre><code class="language-js"><span class="hljs-comment">// 親に当たるオブジェクトが this になる。</span>
<span class="hljs-keyword">let</span> user1 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hawk&#x27;</span>,
    <span class="hljs-attr">getName1</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>
    },
    <span class="hljs-title function_">getName2</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>
    }
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-title function_">getName1</span>());  <span class="hljs-comment">// hawk</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-title function_">getName2</span>());  <span class="hljs-comment">// hawk</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-regexp">//</span> メソッドを付け替えると、その後の親に当たるオブジェクトがthisになる。
<span class="hljs-regexp">//</span> 「user1」オブジェクト
let user1 = {
    name: <span class="hljs-string">&#x27;hawk&#x27;</span>,
    getName: <span class="hljs-keyword">function</span>() {
        return this.name;
    }
};

<span class="hljs-regexp">//</span> 「user2」オブジェクト
let user2 = {
    name: <span class="hljs-string">&#x27;snake&#x27;</span>
};

<span class="hljs-regexp">//</span> メソッドの付け替え
<span class="hljs-regexp">//</span> メソッドを付け替えると、その後の親に当たるオブジェクトが this になる
user2.getName = user1.getName;

console.log(user1.getName());  <span class="hljs-regexp">//</span> hawk
console.log(user2.getName());  <span class="hljs-regexp">//</span> snake
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 関数から new 演算子でオブジェクトを作る</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Enemy</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;dark king&#x27;</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
    }
}

<span class="hljs-comment">// 関数「Enemy」を雛形にして、インスタンス（実体のオブジェクト）を作る</span>
<span class="hljs-keyword">let</span> enemy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enemy</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(enemy.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// dark king</span>
</code></pre>
<p>　アロー関数は、 function で作った関数と全く同じではない。関数スコープを作らない。「this」が指す対象は、関数スコープごとに変わる。そのため、アロー関数内では「this」が指す対象が変化しない。また、アロー関数は new 演算子を使ってインスタンス（実体）を作れない。</p>
<h3 id="section-34">● その他</h3>
<p>　「MDN 関数」でGoogle検索すれば、関数の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions">https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions</a></p>
<p>　「MDN this」でGoogle検索すれば、 this の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/this">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/this</a></p>
<hr>
<h2 id="section-35">■ 様々な値と if 文</h2>
<h3 id="section-36">● undefined と null</h3>
<p>　「undefined」は「未定義」を表す。変数を宣言して未定義な時、中身は「undefined」になる。<br>　関数で、「return」で値を戻さなかった場合の戻り値も「undefined」になる。関数の引数に値を入れなかった時も、その引数は「undefined」になる。値が入っていない配列の要素や、オブジェクトのプロパティを参照した場合も「undefined」になる。<br>　明示的に値を指定していないものは、基本的に「undefined」になる。<br>　「null」はnull値である。明示的に「何も入っていない」ことを表す値である。<br>　「undefined == null」は「true」である。区別を付けたい際は、より厳密な比較演算子「===」を使う。「undefined === null」は「false」である。</p>
<h3 id="section-37">● &#39;&#39; と 0 とfalse</h3>
<p>　「&#39;&#39;」は空文字、「0」は数値の0、「false」は真偽値の「偽」である。<br>　「&#39;&#39; == 0」「&#39;&#39; == false」「0 == false」は「true」である。区別を付けたい際は、より厳密な比較演算子「===」を使う。「&#39;&#39; === 0」「&#39;&#39; === false」「0 === false」は「false」である。</p>
<h3 id="section-38">● if 文</h3>
<p>　以下のように、条件式と処理を書く。最初に「真」の時の処理、else以降は「偽」の時の処理。</p>
<pre><code class="language-js"><span class="language-xml">if (条件式) </span><span class="hljs-template-variable">{真の時の処理}</span><span class="language-xml">
if (条件式) </span><span class="hljs-template-variable">{真の時の処理}</span><span class="language-xml"> else </span><span class="hljs-template-variable">{偽の時の処理}</span><span class="language-xml">
if (条件式) </span><span class="hljs-template-variable">{真の時の処理}</span><span class="language-xml"> else if (条件式2) </span><span class="hljs-template-variable">{条件式2が真の時の処理}</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> 文用の関数
const <span class="hljs-keyword">func</span> = <span class="hljs-keyword">function</span>(arg) {
    <span class="hljs-keyword">if</span> (arg &lt;= <span class="hljs-number">1</span>) {
        console.log(arg, <span class="hljs-string">&#x27;は1以下&#x27;</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg &lt;= <span class="hljs-number">5</span>) {
        console.log(arg, <span class="hljs-string">&#x27;は1より大きく、5以下&#x27;</span>);
    } <span class="hljs-keyword">else</span> {
        console.log(arg, <span class="hljs-string">&#x27;は5より大きい&#x27;</span>);
    }
}

<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>から<span class="hljs-number">9</span>まで処理を実行
<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++) {
    <span class="hljs-keyword">func</span>(i);
}

<span class="hljs-regexp">//</span> <span class="hljs-number">0</span> は<span class="hljs-number">1</span>以下
<span class="hljs-regexp">//</span> <span class="hljs-number">1</span> は<span class="hljs-number">1</span>以下
<span class="hljs-regexp">//</span> <span class="hljs-number">2</span> は<span class="hljs-number">1</span>より大きく、<span class="hljs-number">5</span>以下
<span class="hljs-regexp">//</span> <span class="hljs-number">3</span> は<span class="hljs-number">1</span>より大きく、<span class="hljs-number">5</span>以下
<span class="hljs-regexp">//</span> <span class="hljs-number">4</span> は<span class="hljs-number">1</span>より大きく、<span class="hljs-number">5</span>以下
<span class="hljs-regexp">//</span> <span class="hljs-number">5</span> は<span class="hljs-number">1</span>より大きく、<span class="hljs-number">5</span>以下
<span class="hljs-regexp">//</span> <span class="hljs-number">6</span> は<span class="hljs-number">5</span>より大きい
<span class="hljs-regexp">//</span> <span class="hljs-number">7</span> は<span class="hljs-number">5</span>より大きい
<span class="hljs-regexp">//</span> <span class="hljs-number">8</span> は<span class="hljs-number">5</span>より大きい
<span class="hljs-regexp">//</span> <span class="hljs-number">9</span> は<span class="hljs-number">5</span>より大きい
</code></pre>
<p>　条件式は、「false」「undefined」「null」「&#39;&#39;」「0」は「偽」と見なす。</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>)     {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;真&#x27;</span>)} <span class="hljs-keyword">else</span> {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;偽&#x27;</span>)}  <span class="hljs-comment">// 偽</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">undefined</span>) {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;真&#x27;</span>)} <span class="hljs-keyword">else</span> {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;偽&#x27;</span>)}  <span class="hljs-comment">// 偽</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span>)      {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;真&#x27;</span>)} <span class="hljs-keyword">else</span> {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;偽&#x27;</span>)}  <span class="hljs-comment">// 偽</span>
<span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;&#x27;</span>)        {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;真&#x27;</span>)} <span class="hljs-keyword">else</span> {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;偽&#x27;</span>)}  <span class="hljs-comment">// 偽</span>
<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>)         {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;真&#x27;</span>)} <span class="hljs-keyword">else</span> {<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;偽&#x27;</span>)}  <span class="hljs-comment">// 偽</span>
</code></pre>
<hr>
<h2 id="section-39">■ エラー処理</h2>
<h3 id="section-40">● try catch 文</h3>
<p>　「try { }」の中でエラーをキャッチして、「catch(e) { }」の中で、エラー発生時の処理を書ける。「e」にはエラーの情報が入る。</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
    const <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;{name: &quot;Ken&quot;, hp: 100}&#x27;</span>;
    const obj = JSON.parse(<span class="hljs-built_in">str</span>);
    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;[Success]&#x27;</span>, obj);
} <span class="hljs-keyword">catch</span>(e) {
    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;[Error]&#x27;</span>, e);
}

<span class="hljs-comment">// [Success] { name: &#x27;Ken&#x27;, hp: 100 }</span>
<span class="hljs-comment">// [Error] SyntaxError: Unexpected token n in JSON at position 1</span>
<span class="hljs-comment">//     （詳細なエラー情報）</span>
</code></pre>
<h3 id="section-41">● throw 文</h3>
<p>　「throw」を使うことで、エラー情報を引き渡してエラーを発生させられる。文字列を渡す以外に、エラー オブジェクトを渡すこともできる。エラー オブジェクトを渡せば、エラーの発生行などの情報を伝達可能。</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Oh!&#x27;</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Success]&#x27;</span>)
} <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Error]&#x27;</span>, e)
}

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;happning!&#x27;</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Success]&#x27;</span>);
} <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Error]&#x27;</span>, e);
}

<span class="hljs-comment">// &lt;2-2&gt; [Error] Oh!</span>
<span class="hljs-comment">// &lt;2-4&gt; [Error] Error: happning!</span>
<span class="hljs-comment">//     （詳細なエラー情報）</span>
</code></pre>
<h3 id="section-42">● エラーのネスト</h3>
<p>　エラーはキャッチされるまで、関数のネストをさかのぼっていく。最後までキャッチされないと、処理が停止する。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> func1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;func1: start&#x27;</span>);

    <span class="hljs-keyword">const</span> func2 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;func2: start&#x27;</span>);

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;happning!&#x27;</span>);

        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;func2: end&#x27;</span>);
    };
    <span class="hljs-title function_">func2</span>();

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;func1: end&#x27;</span>);
};

<span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;try&#x27;</span>)
    <span class="hljs-title function_">func1</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Success]&#x27;</span>)
} <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Error]&#x27;</span>, e)
}

<span class="hljs-comment">// try</span>
<span class="hljs-comment">// func1: start</span>
<span class="hljs-comment">// func2: start</span>
<span class="hljs-comment">// [Error] Error: happning!</span>
<span class="hljs-comment">//     （詳細なエラー情報）</span>
</code></pre>
<h3 id="section-43">● その他</h3>
<p>　「MDN try catch」でGoogle検索すれば、try catch 文の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/try...catch">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/try...catch</a></p>
<p>　「MDN throw」でGoogle検索すれば、throw 文の仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/throw">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/throw</a></p>
<hr>
<h2 id="section-44">■ クラス</h2>
<h3 id="section-45">● クラスの宣言とインスタンスの利用</h3>
<p>　「class」を宣言することで、new演算子でインスタンス（実体）を作るクラスを作成できる。インスタンス作成時には、「constructer」メソッドが実行される。</p>
<pre><code class="language-js"><span class="hljs-comment">// クラスの作成</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Chara</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hp</span> = <span class="hljs-number">100</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">mp</span> = <span class="hljs-number">50</span>;
    }
    <span class="hljs-title function_">getStatus</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> : hp <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.hp}</span>, mp <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.mp}</span>`</span>;
    }
}

<span class="hljs-comment">// クラスから new 演算子でオブジェクトを作成</span>
<span class="hljs-keyword">let</span> enemy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chara</span>(<span class="hljs-string">&#x27;slime&#x27;</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(enemy.<span class="hljs-property">name</span>);         <span class="hljs-comment">// slime</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(enemy.<span class="hljs-title function_">getStatus</span>());  <span class="hljs-comment">// slime : hp 100, mp 50</span>
</code></pre>
<h3 id="section-46">● 静的プロパティと静的メソッド</h3>
<p>　クラス固有の静的プロパティや静的メソッドを作りたい時は「static」を使う。</p>
<pre><code class="language-js"><span class="hljs-comment">// クラスの作成</span>
<span class="hljs-comment">// 静的プロパティや静的メソッドを作る</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Chara</span> {
    <span class="hljs-keyword">static</span> nameDefalt = <span class="hljs-string">&#x27;unknown&#x27;</span>;
    <span class="hljs-keyword">static</span> hpDefalt = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">static</span> mpDefalt = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getStatusDefault</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.nameDefalt}</span> : hp <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.hpDefalt}</span>, mp <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.mpDefalt}</span>`</span>;
    }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Chara</span>.<span class="hljs-property">nameDefalt</span>);          <span class="hljs-comment">// unknown</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Chara</span>.<span class="hljs-title function_">getStatusDefault</span>());  <span class="hljs-comment">// unknown : hp 10, mp 5</span>
</code></pre>
<h3 id="section-47">● その他</h3>
<p>　「MDN クラス」でGoogle検索すれば、クラスの仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes</a></p>
<hr>
<h2 id="section-48">■ DOM操作</h2>
<h3 id="section-49">● DOMの準備が終わったあとに処理を実行</h3>
<p>　DOMの要素は、HTMLが読み込まれてDOMの解析が終わるまで操作することができない。そのため、DOMの準備が整うまで待ったあと、処理を実行する必要がある。「window.addEventListener(&#39;DOMContentLoaded&#39;, ＜関数＞)」を使うことで、処理を待ったあと関数を実行できる。</p>
<pre><code class="language-js"><span class="hljs-comment">// DOMの準備が終わったあとに処理を実行</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOMの準備が完了&#x27;</span>);
});
</code></pre>
<h3 id="section-50">● DOM要素の取得</h3>
<p>　「document.querySelector(CSSセレクタの文字列)」で、要素を1つ選択可能。該当なしの場合は「null」が返る。</p>
<pre><code class="language-js"><span class="hljs-comment">// 要素を選択</span>
let element = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#id&#x27;</span>);
</code></pre>
<p>　「document.querySelectorAll(CSSセレクタの文字列)」で要素を複数選択可能。「NodeList」（配列に似た物）が返る。該当なしの場合は、空の「NodeList」が返る。「Array.from()」と組み合わせて、配列として受け取るとよい。</p>
<pre><code class="language-js"><span class="hljs-comment">// 要素を全て選択</span>
<span class="hljs-keyword">let</span> nodeList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.news&#x27;</span>);
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(nodeList));
</code></pre>
<h3 id="section-51">● 属性の取得と書き換え</h3>
<p>　「.属性」で操作できる。</p>
<pre><code class="language-js"><span class="hljs-comment">// a 要素の target の値を取得したあと書き換え</span>
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;a&#x27;</span>));
elementArray.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> target = element.<span class="hljs-property">target</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);
    element.<span class="hljs-property">target</span> = <span class="hljs-string">&#x27;_blank&#x27;</span>;
});
</code></pre>
<h3 id="section-52">● 内部のHTMLの書き換え</h3>
<p>　「.innerHTML」を使うと、内部のHTMLを書き換えられる。</p>
<pre><code class="language-js"><span class="hljs-comment">// a 要素内の HTML を書き換え</span>
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;a&#x27;</span>));
elementArray.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
    element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;hogehoge&#x27;</span>;
});
</code></pre>
<h3 id="section-53">● スタイルの書き換え</h3>
<p>　「.style.スタイルの名前」で書き換えられる。</p>
<pre><code class="language-js"><span class="hljs-comment">// a 要素の文字色を赤に変える</span>
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;a&#x27;</span>));
elementArray.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
    element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;
});
</code></pre>
<h3 id="section-54">● クラスの書き換え</h3>
<p>　「.classList.＜各種メソッド＞」で、クラスを追加したり削除したり、切り換えたりできる。</p>
<pre><code class="language-js"><span class="hljs-comment">// a 要素のクラスを書き換え</span>
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;a&#x27;</span>));
elementArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
    element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;big&#x27;</span>);
});
</code></pre>
<h3 id="section-55">● フォームの値の操作</h3>
<p>　「.value」を使い、フォームの値を操作できる。</p>
<pre><code class="language-js"><span class="hljs-comment">// フォームの部品の値を JavaScript! に書き換える</span>
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;input&#x27;</span>));
elementArray.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
    element.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;JavaScript!&#x27;</span>;
});
</code></pre>
<h3 id="section-56">● イベント処理</h3>
<p>　「.addEventListener()」を使い、イベントの種類と、イベント発生時に呼び出される関数を書くと、その要素でイベントが発生したときの処理を書ける。</p>
<pre><code class="language-js"><span class="hljs-comment">// フォームの部品をクリックすると、その部品の値とイベントオブジェクトを出力する</span>
<span class="hljs-keyword">let</span> elementArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;input&#x27;</span>));
elementArray.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
    element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, e);
    });
});
</code></pre>
<p>　イベント発生時の関数には、イベントの詳細が入ったオブジェクトが引数として渡される。イベント発生時の関数のthisは、そのイベントが起きたオブジェクトになる。</p>
<hr>
<h2 id="section-57">■ 非同期処理と Promise</h2>
<h3 id="section-58">● 非同期処理</h3>
<p>　JavaScript は基本的に、シングル スレッドで処理をおこなう。そのため時間の掛かる処理を待たずに処理を進める「非同期処理」が用いることが多い。そうすることで、 Web ブラウザの UI を止めることなく、処理をおこなえる。<br>　JavaScript では関数を実行する場合に、「処理終了後に実行する関数」を引数にして渡すことが多い。「関数(引数1, 引数2, ..., 終了後に実行する関数)」のように書く。こうした引数の関数のことをコールバック関数と呼ぶ。待ち時間がある処理では、コールバック関数は時間差で実行される。<br>　時間が掛かる処理が終わってから次の時間が掛かる処理をおこなう。そうしたことを複数回おこなうと、 JavaScript では関数のネストが深くなる。</p>
<pre><code class="language-js">時間が掛かる処理<span class="hljs-comment">(引数1, 引数2, ..., 終了後に実行する関数()</span> {
    時間が掛かる処理<span class="hljs-comment">(引数1, 引数2, ..., 終了後に実行する関数()</span> {
        時間が掛かる処理<span class="hljs-comment">(引数1, 引数2, ..., 終了後に実行する関数()</span> {
            時間が掛かる処理<span class="hljs-comment">(引数1, 引数2, ..., 終了後に実行する関数()</span> {
            })
        })
    })
})
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// ネストが深い非同期処理</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1つめの処理&#x27;</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2つめの処理&#x27;</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3つめの処理&#x27;</span>);
        }, <span class="hljs-number">1000</span>);
    }, <span class="hljs-number">1000</span>);
}, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// 1つめの処理</span>
<span class="hljs-comment">// 2つめの処理</span>
<span class="hljs-comment">// 3つめの処理</span>
</code></pre>
<p>　こうした問題を解決するために、 Promise という文法が JavaScript に追加された。</p>
<h3 id="section-59">● Promise resolve then</h3>
<p>　Promise オブジェクトは、関数を引数に取る。引数の関数内で、「resolve()」（解決）を実行すると、 Promise オブジェクトの後続の「then()」内の関数を実行する。<br>　「then()」内の関数で Promise オブジェクトを返せば、同じように「resole()」実行時に、後続の「then()」や「catch()」内の関数を実行する。<br>　この仕組みは、文章で書くと分かり難いので、コードの形で書く。この段階では、まだあまり便利なようには見えない。</p>
<pre><code class="language-js"><span class="hljs-comment">// Promise を利用した非同期処理</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1つめの処理&#x27;</span>);
        <span class="hljs-title function_">resolve</span>();
    }, <span class="hljs-number">1000</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2つめの処理&#x27;</span>);
            <span class="hljs-title function_">resolve</span>();
        }, <span class="hljs-number">1000</span>);
    });
})
.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3つめの処理&#x27;</span>);
            <span class="hljs-title function_">resolve</span>();
        }, <span class="hljs-number">1000</span>);
    });
});

<span class="hljs-comment">// 1つめの処理</span>
<span class="hljs-comment">// 2つめの処理</span>
<span class="hljs-comment">// 3つめの処理</span>
</code></pre>
<p>　「resoleve()」を実行すると、後続の「then()」の第1引数の関数が実行される。</p>
<h3 id="section-60">● Promise resolve then 2</h3>
<p>　「resoleve()」や「reject()」に引数を付けると、その値を次の処理に送ることができる。<br>　また、多くの場合、 Promise オブジェクトを返す関数を用意しておき、処理を簡素に書く。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> wait = <span class="hljs-keyword">function</span>(<span class="hljs-params">time</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${time}</span>ミリ秒`</span>);
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`end: <span class="hljs-subst">${time}</span>`</span>);
        }, time);
    });
}

<span class="hljs-title function_">wait</span>(<span class="hljs-number">2000</span>)
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">1500</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">1000</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">500</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
});

<span class="hljs-comment">// 2000ミリ秒</span>
<span class="hljs-comment">// end: 2000</span>
<span class="hljs-comment">// 1500ミリ秒</span>
<span class="hljs-comment">// end: 1500</span>
<span class="hljs-comment">// 1000ミリ秒</span>
<span class="hljs-comment">// end: 1000</span>
<span class="hljs-comment">// 500ミリ秒</span>
<span class="hljs-comment">// end: 500</span>
</code></pre>
<h3 id="section-61">● async と await</h3>
<p>　Promiseの処理は、関数ブロックの先頭に「async」を書き、 Promise オブジェクトを返す関数の前に「await」を書くことで、シンプルに書くことができる。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> wait = <span class="hljs-keyword">function</span>(<span class="hljs-params">time</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${time}</span>ミリ秒`</span>);
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`end: <span class="hljs-subst">${time}</span>`</span>);
        }, time);
    });
};

(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">2000</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">1500</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">500</span>);
})();

<span class="hljs-comment">// 2000ミリ秒</span>
<span class="hljs-comment">// 1500ミリ秒</span>
<span class="hljs-comment">// 1000ミリ秒</span>
<span class="hljs-comment">// 500ミリ秒</span>
</code></pre>
<h3 id="section-62">● Promise reject catch</h3>
<p>　Promise オブジェクトの引数の関数内で「reject()」（拒否）を実行すると、 Promise オブジェクトの後続の「then()」の第2引数の関数が実行される。あるいは、後続の最初の「catch()」まで処理が移動する。</p>
<pre><code class="language-js"><span class="hljs-comment">// then の2つめの関数を設置</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1つめの処理&#x27;</span>);
        <span class="hljs-title function_">reject</span>();
    }, <span class="hljs-number">1000</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolveである&#x27;</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>();
        }, <span class="hljs-number">1000</span>);
    });
}, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejectである&#x27;</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>();
        }, <span class="hljs-number">1000</span>);
    });
});

<span class="hljs-comment">// 1つめの処理</span>
<span class="hljs-comment">// rejectである</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// catch の使用。最初の reject で一気に catch まで飛ぶ。</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1つめの処理&#x27;</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">reject</span>();
    }, <span class="hljs-number">1000</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2つめの処理&#x27;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>();
        }, <span class="hljs-number">1000</span>);
    });
})
.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3つめの処理&#x27;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>();
        }, <span class="hljs-number">1000</span>);
    });
})
.<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catchした&#x27;</span>);
});

<span class="hljs-comment">// 1つめの処理</span>
<span class="hljs-comment">// catchした</span>
</code></pre>
<h3 id="section-63">● Promise の静的メソッド</h3>
<p>　Promiseには、いくつかの静的メソッドがある。、全て待ってから進む「Promise.all()」は、よく使う。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> wait = <span class="hljs-keyword">function</span>(<span class="hljs-params">time</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${time}</span>ミリ秒`</span>);
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`end: <span class="hljs-subst">${time}</span>`</span>);
        }, time);
    });
}

<span class="hljs-comment">// Promise オブジェクトの配列を作る</span>
<span class="hljs-keyword">let</span> arr = [];
arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">wait</span>(<span class="hljs-number">2000</span>));
arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">wait</span>(<span class="hljs-number">1500</span>));
arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">wait</span>(<span class="hljs-number">1000</span>));
arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">wait</span>(<span class="hljs-number">500</span>));

<span class="hljs-comment">// 全て解決するまで待つ</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(arr)
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;終了&#x27;</span>, res);
});

<span class="hljs-comment">// 500ミリ秒</span>
<span class="hljs-comment">// 1000ミリ秒</span>
<span class="hljs-comment">// 1500ミリ秒</span>
<span class="hljs-comment">// 2000ミリ秒</span>
<span class="hljs-comment">// 終了 (4) [&#x27;end: 2000&#x27;, &#x27;end: 1500&#x27;, &#x27;end: 1000&#x27;, &#x27;end: 500&#x27;]</span>
</code></pre>
<h3 id="section-64">● その他</h3>
<p>　「MDN Promise」でGoogle検索すれば、Promiseの仕様が分かる。</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>

  </body>
</html>